<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Video Poker with Joker</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --card-width: 80px;
            --card-height: 110px;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            padding-top: 2vh; 
            min-height: 100vh;
            margin: 0;
            user-select: none;
            overflow-y: auto; 
            overflow-x: hidden;
            box-sizing: border-box;
            padding-bottom: 80px;
        }

        .game-title {
            font-size: 1.5rem;
            margin: 0 0 10px 0;
            color: #f1c40f;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            font-weight: bold;
            z-index: 10;
            text-align: center;
            flex-shrink: 0;
            display: block;
        }

        .info-panel {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 1.1rem;
            margin-bottom: 80px; 
            background: #34495e;
            padding: 10px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            white-space: nowrap;
            z-index: 10; 
            flex-shrink: 0;
            width: 90%;
            max-width: 600px;
            box-sizing: border-box;
        }

        .info-panel > div {
            text-align: center;
        }

        .card-container {
            display: flex;
            gap: 8px;
            perspective: 1000px;
            justify-content: center;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 5;
            max-width: 600px;
            flex-shrink: 0;
        }

        .card-wrapper {
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.2s;
        }

        .card-wrapper.held {
            transform: translateY(-15px);
        }

        .card {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.4s;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            font-size: 3rem; 
            font-weight: bold;
        }

        .card.is-back {
            transform: rotateY(180deg);
        }

        .card-inner {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
            border-radius: 6px;
            top: 0; left: 0;
            background-color: white;
            line-height: 1;
            padding-top: 5px;
        }

        .card-front {
            transform: rotateY(0deg);
            z-index: 2;
        }
        .card-front.red { color: #e74c3c; }
        .card-front.black { color: #2c3e50; }
        /* ジョーカー用カラー */
        .card-front.joker { color: #8e44ad; } 

        .card-back {
            transform: rotateY(180deg);
            background: repeating-linear-gradient(
                45deg,
                #606dbc,
                #606dbc 10px,
                #465298 10px,
                #465298 20px
            );
            z-index: 1;
        }

        .card-suit { 
            font-size: 4.5rem; 
            margin-top: -5px;
            line-height: 1;
        }
        
        /* ジョーカーの文字調整 */
        .joker-text {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }

        .status-badge {
            position: absolute;
            top: -26px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f1c40f;
            color: #2c3e50;
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .visible { opacity: 1; }
        .status-badge.dealer { background-color: #95a5a6; color: white; }
        .status-badge.win { background-color: #e74c3c; color: white; }
        .status-badge.lose { background-color: #34495e; color: white; }

        .controls {
            margin-top: 3vh;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            position: relative;
            z-index: 50;
            flex-shrink: 0;
        }

        .auto-panel {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 50;
        }
        
        select {
            padding: 8px;
            border-radius: 5px;
            border: none;
            font-weight: bold;
            color: #2c3e50;
        }

        button {
            padding: 12px 18px;
            font-size: 0.95rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s, transform 0.1s;
            touch-action: manipulation;
        }
        button:active { transform: scale(0.96); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .btn-bet { background-color: #3498db; color: white; flex: 1; min-width: 80px;}
        .btn-action { background-color: #e67e22; color: white; width: 130px; font-size: 1.1rem;}
        .btn-collect { background-color: #27ae60; color: white; flex: 1; min-width: 100px;}
        .btn-double { background-color: #9b59b6; color: white; flex: 1; min-width: 100px;}
        
        .btn-auto { 
            background-color: #009688; 
            color: white; 
            min-width: 100px;
        }
        .btn-auto.active {
            background-color: #c0392b; 
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #message-area {
            height: 30px;
            margin-top: 2vh;
            font-size: 1.2rem;
            color: #f1c40f;
            font-weight: bold;
            text-align: center;
            padding: 0 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            flex-shrink: 0;
        }

        .paytable {
            margin-top: 15px;
            font-size: 0.75rem;
            color: #95a5a6;
            text-align: center;
            line-height: 1.5;
            max-width: 90%;
            z-index: 10;
            flex-shrink: 0;
        }

        @media (max-width: 600px) {
            .game-title { font-size: 1.3rem; margin-bottom: 5px; }
            .info-panel { 
                font-size: 0.9rem; 
                padding: 8px 15px; 
                width: 95%; 
                margin-bottom: 60px; 
                justify-content: center; 
            }
            .card-wrapper { width: 17vw; height: 24vw; }
            .card { font-size: 2.2rem; } 
            .card-suit { font-size: 3.5rem; }
            .joker-text { font-size: 0.9rem; }
            .status-badge { top: -22px; font-size: 0.6rem; padding: 2px 5px; }
            .controls { padding: 0 10px; margin-top: 2vh; }
            button { padding: 10px 10px; font-size: 0.85rem; }
            .auto-panel { margin-top: 10px; padding: 5px; }
        }
        
        @media (orientation: landscape) and (max-height: 500px) {
            body { padding-top: 5px; }
            .game-title { display: block; font-size: 1.1rem; margin-bottom: 5px;}
            .info-panel { margin-bottom: 50px; padding: 5px 15px; }
            .card-wrapper { width: 50px; height: 70px; }
            .card { font-size: 1.8rem; }
            .card-suit { font-size: 2.5rem; }
            .paytable { display: none; }
            .auto-panel { margin-top: 5px; }
        }
    </style>
</head>
<body>

    <h1 class="game-title">Video Poker & Joker</h1>

    <div class="info-panel">
        <div>CREDITS: <span id="credits">100</span></div>
        <div>BET: <span id="bet">1</span></div>
        <div>WIN: <span id="win">0</span></div>
    </div>

    <div class="card-container" id="card-area">
        </div>

    <div id="message-area">GOOD LUCK!</div>

    <div class="controls">
        <button id="btn-bet-one" class="btn-bet" onclick="changeBet(1)">BET +1</button>
        <button id="btn-bet-max" class="btn-bet" onclick="changeBet(5)">MAX BET</button>
        <button id="btn-deal" class="btn-action" onclick="dealOrDraw()">DEAL</button>
        <div id="double-controls" style="display:none; gap:10px; width: 100%; justify-content: center;">
            <button class="btn-double" onclick="startDoubleUp()">DOUBLE UP</button>
            <button class="btn-collect" onclick="collectWin()">COLLECT</button>
        </div>
    </div>

    <div class="auto-panel">
        <div style="font-size: 0.9rem; font-weight:bold;">AUTO:</div>
        <select id="risk-select">
            <option value="low">Conservative</option>
            <option value="mid" selected>Balanced</option>
            <option value="high">Aggressive</option>
        </select>
        <button id="btn-auto" class="btn-auto" onclick="toggleAuto()">START</button>
    </div>

    <div class="paytable">
        ROYAL:800 | 5K:50 | SF:50 | 4K:25 | FH:9 | FL:6 <br>
        ST:4 | 3K:3 | 2P:2 | JOB:1 (Joker Wild)
    </div>

<script>
    const SUITS = ['♠', '♣', '♥', '♦'];
    const RANKS = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
    const RANK_STR = {11:'J', 12:'Q', 13:'K', 14:'A'};

    let deck = [];
    let hand = []; 
    let held = [false, false, false, false, false]; 
    let credits = 100;
    let bet = 1;
    let winAmount = 0;
    let gameState = 'BETTING'; 
    
    let isAutoMode = false;
    let autoInterval = null;
    let consecutiveDoubles = 0;
    
    const els = {
        credits: document.getElementById('credits'),
        bet: document.getElementById('bet'),
        win: document.getElementById('win'),
        msg: document.getElementById('message-area'),
        cardArea: document.getElementById('card-area'),
        btnDeal: document.getElementById('btn-deal'),
        btnBetOne: document.getElementById('btn-bet-one'),
        btnBetMax: document.getElementById('btn-bet-max'),
        doubleControls: document.getElementById('double-controls'),
        btnAuto: document.getElementById('btn-auto'),
        riskSelect: document.getElementById('risk-select')
    };

    function init() {
        createCardElements();
        updateUI();
    }

    function createCardElements() {
        els.cardArea.innerHTML = '';
        for(let i=0; i<5; i++) {
            let wrapper = document.createElement('div');
            wrapper.className = 'card-wrapper';
            wrapper.id = `wrapper-${i}`;
            wrapper.onclick = () => onCardClick(i);

            let badge = document.createElement('div');
            badge.className = 'status-badge';
            badge.innerText = 'HOLD';
            badge.id = `badge-${i}`;

            let cardDiv = document.createElement('div');
            cardDiv.className = 'card is-back'; 
            cardDiv.id = `card-${i}`;

            let backDiv = document.createElement('div');
            backDiv.className = 'card-inner card-back';
            
            let frontDiv = document.createElement('div');
            frontDiv.className = 'card-inner card-front';
            frontDiv.id = `card-front-${i}`;

            cardDiv.appendChild(backDiv);
            cardDiv.appendChild(frontDiv);
            wrapper.appendChild(badge);
            wrapper.appendChild(cardDiv);
            els.cardArea.appendChild(wrapper);
        }
    }

    function createDeck() {
        deck = [];
        for (let s of SUITS) {
            for (let r of RANKS) {
                deck.push({ suit: s, rank: r, isJoker: false });
            }
        }
        // Add Joker (Rank 0 or 15 for logic, treat specially)
        deck.push({ suit: '★', rank: 15, isJoker: true });

        // Shuffle
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }

    function changeBet(amount) {
        if (gameState !== 'BETTING') return;
        if (amount === 5) {
            bet = 5;
        } else {
            bet += amount;
            if (bet > 5) bet = 1;
        }
        if (bet > credits && credits > 0) bet = credits; 
        updateUI();
    }

    function dealOrDraw() {
        if (gameState === 'BETTING') {
            startDealSequence();
        } else if (gameState === 'PLAYING') {
            startDrawSequence();
        } else if (gameState === 'GAME_OVER') {
            resetGame();
        }
    }

    function startDealSequence() {
        if (credits < bet) {
            els.msg.innerText = "Not enough credits!";
            if(isAutoMode) toggleAuto(); 
            return;
        }
        credits -= bet;
        winAmount = 0;
        consecutiveDoubles = 0; 
        createDeck();
        hand = [];
        held = [false, false, false, false, false];
        
        for(let i=0; i<5; i++) {
            let w = document.getElementById(`wrapper-${i}`);
            let c = document.getElementById(`card-${i}`);
            let b = document.getElementById(`badge-${i}`);
            w.classList.remove('held');
            c.classList.add('is-back');
            b.innerText = "HOLD"; 
            b.className = "status-badge"; 
            b.classList.remove('visible');
        }

        for(let i=0; i<5; i++) hand.push(deck.pop());
        
        gameState = 'ANIMATING'; 
        els.msg.innerText = "Dealing...";
        updateUI();

        let delayBase = 100; 
        for(let i=0; i<5; i++) {
            setTimeout(() => {
                updateCardVisual(i); 
                document.getElementById(`card-${i}`).classList.remove('is-back');
            }, i * delayBase + 100);
        }

        setTimeout(() => {
            gameState = 'PLAYING';
            els.msg.innerText = "Select cards to HOLD";
            updateUI();
        }, 5 * delayBase + 300);
    }

    function startDrawSequence() {
        let indicesToDraw = [];
        for(let i=0; i<5; i++) {
            if(!held[i]) indicesToDraw.push(i);
        }

        if(indicesToDraw.length === 0) {
            evaluateHand(); 
            return;
        }

        gameState = 'ANIMATING';
        updateUI(); 

        indicesToDraw.forEach(i => {
            document.getElementById(`card-${i}`).classList.add('is-back');
        });

        setTimeout(() => {
            try {
                indicesToDraw.forEach(i => {
                    if (deck.length > 0) hand[i] = deck.pop();
                    updateCardVisual(i); 
                });
                
                let delayStep = 150;
                indicesToDraw.forEach((cardIdx, seqIdx) => {
                    setTimeout(() => {
                        document.getElementById(`card-${cardIdx}`).classList.remove('is-back');
                    }, seqIdx * delayStep + 50);
                });

                setTimeout(() => {
                    evaluateHand();
                }, indicesToDraw.length * delayStep + 400);

            } catch (e) {
                console.error("Error during draw:", e);
                evaluateHand();
            }
        }, 400); 
    }

    function resetGame() {
        credits = 100; 
        bet = 1;
        winAmount = 0;
        gameState = 'BETTING';
        hand = []; 
        for(let i=0; i<5; i++) {
            document.getElementById(`card-${i}`).classList.add('is-back');
            document.getElementById(`wrapper-${i}`).classList.remove('held');
            document.getElementById(`badge-${i}`).classList.remove('visible');
        }
        els.msg.innerText = "NEW GAME";
        updateUI();
    }

    function updateCardVisual(i) {
        if (!hand[i]) return;
        let c = hand[i];
        let elFront = document.getElementById(`card-front-${i}`);
        
        let colorClass = 'black';
        let rankDisplay = '';
        let suitDisplay = '';

        if (c.isJoker) {
            colorClass = 'joker';
            rankDisplay = '<div class="joker-text">JOKER</div>';
            suitDisplay = '★';
        } else {
            rankDisplay = RANK_STR[c.rank] || c.rank;
            colorClass = (c.suit === '♥' || c.suit === '♦') ? 'red' : 'black';
            suitDisplay = c.suit;
        }
        
        elFront.className = `card-inner card-front ${colorClass}`;
        if (c.isJoker) {
             elFront.innerHTML = `<div>${rankDisplay}</div><div class="card-suit">${suitDisplay}</div>`;
        } else {
             elFront.innerHTML = `<div>${rankDisplay}</div><div class="card-suit">${suitDisplay}</div>`;
        }
    }

    function onCardClick(index) {
        if (gameState === 'PLAYING') {
            toggleHold(index);
        } else if (gameState === 'DOUBLE_UP') {
            playDoubleUp(index);
        }
    }

    function toggleHold(index) {
        held[index] = !held[index];
        let badgeEl = document.getElementById(`badge-${index}`);
        let wrapperEl = document.getElementById(`wrapper-${index}`);
        badgeEl.classList.toggle('visible', held[index]);
        wrapperEl.classList.toggle('held', held[index]);
    }

    // --- Joker Logic: Best Possible Hand ---
    function evaluateHand() {
        // Use a resolver that considers the Joker
        let bestResult = resolveBestHand(hand);
        
        if (bestResult.payout > 0) {
            winAmount = bet * bestResult.payout;
            els.msg.innerText = `${bestResult.handName} !! WIN: ${winAmount}`;
            gameState = 'WIN_DECISION'; 
        } else {
            els.msg.innerText = "GAME OVER";
            loseGame();
        }
        updateUI();
    }

    // Determine best hand with Wild Cards
    function resolveBestHand(currentHand) {
        let jokers = currentHand.filter(c => c.isJoker).length;
        
        if (jokers === 0) {
            return getHandScore(currentHand);
        }

        // Try substituting Joker with every standard card
        let bestScore = { payout: 0, handName: "" };
        let tempHand = currentHand.filter(c => !c.isJoker); // Remove jokers

        // Construct standard deck reference
        let standardDeck = [];
        for (let s of SUITS) {
            for (let r of RANKS) {
                standardDeck.push({ suit: s, rank: r });
            }
        }

        // Brute force: Try adding 1 card for 1 joker
        // (If multiple jokers were allowed, we'd need recursion, but for 1 joker this is fast)
        for (let card of standardDeck) {
            // Can't use a card that's already visible in the hand
            if (tempHand.some(c => c.rank === card.rank && c.suit === card.suit)) continue;

            let testHand = [...tempHand, card];
            let score = getHandScore(testHand);
            
            if (score.payout > bestScore.payout) {
                bestScore = score;
            }
        }
        
        // Special Case: 5 of a Kind (Natural 4 + Joker)
        // The standard evaluate logic assumes 5 cards. 
        // 5 of a kind needs a specific check or the loop above finds 4 of a kind and upgrades.
        // Actually, if we have 4 of a kind + Joker, the loop tries a card matching the 4.
        // Result is 5 cards of same rank.
        
        return bestScore;
    }

    // Standard Evaluation Logic (5 cards, no wild logic internal)
    function getHandScore(cards) {
        let ranks = cards.map(c => c.rank).sort((a,b) => a-b);
        let suits = cards.map(c => c.suit);
        let isFlush = suits.every(s => s === suits[0]);
        
        let isStraight = true;
        for(let i=0; i<4; i++) if(ranks[i+1] !== ranks[i] + 1) isStraight = false;
        if (!isStraight && ranks.join(',') === '2,3,4,5,14') isStraight = true;

        let counts = {};
        ranks.forEach(x => { counts[x] = (counts[x] || 0) + 1; });
        let countValues = Object.values(counts);

        if (countValues.includes(5)) return { payout: 50, handName: "FIVE OF A KIND" };
        if (isFlush && isStraight && ranks[0] === 10) return { payout: 800, handName: "ROYAL FLUSH" };
        if (isFlush && isStraight) return { payout: 50, handName: "STRAIGHT FLUSH" };
        if (countValues.includes(4)) return { payout: 25, handName: "FOUR OF A KIND" };
        if (countValues.includes(3) && countValues.includes(2)) return { payout: 9, handName: "FULL HOUSE" };
        if (isFlush) return { payout: 6, handName: "FLUSH" };
        if (isStraight) return { payout: 4, handName: "STRAIGHT" };
        if (countValues.includes(3)) return { payout: 3, handName: "THREE OF A KIND" };
        if (countValues.filter(x => x === 2).length === 2) return { payout: 2, handName: "TWO PAIR" };
        if (countValues.includes(2)) {
            // Pair check for J or better
            // Note: In Wild games, often pair of Kings is required, but we stick to Jacks
            // Also, Five of a Kind logic via joker might end up here if not handled? No, counts would be 5.
            let pairs = Object.keys(counts).filter(key => counts[key] === 2);
            let isJob = pairs.some(r => parseInt(r) >= 11);
            if (isJob) return { payout: 1, handName: "JACKS OR BETTER" };
        }
        
        return { payout: 0, handName: "" };
    }

    function startDoubleUp() {
        gameState = 'DOUBLE_UP';
        createDeck();
        hand = []; 
        let dealerCard = deck.pop();
        hand.push(dealerCard);
        for(let i=0; i<4; i++) hand.push(deck.pop());

        for(let i=0; i<5; i++) {
            updateCardVisual(i);
            document.getElementById(`wrapper-${i}`).classList.remove('held');
            let badgeEl = document.getElementById(`badge-${i}`);
            badgeEl.classList.remove('visible');
            badgeEl.className = "status-badge"; 
            
            let cardEl = document.getElementById(`card-${i}`);
            if (i === 0) {
                cardEl.classList.remove('is-back');
            } else {
                cardEl.classList.add('is-back');
            }
        }
        
        let dBadge = document.getElementById('badge-0');
        dBadge.innerText = "DEALER";
        dBadge.classList.add('visible', 'dealer');
        
        for(let i=1; i<5; i++) {
            let pBadge = document.getElementById(`badge-${i}`);
            pBadge.innerText = "HOLD"; 
            pBadge.classList.add('visible');
        }

        els.msg.innerText = "Pick a card higher than Dealer's!";
        updateUI();
    }

    function playDoubleUp(playerIndex) {
        if (playerIndex === 0) return; 

        document.getElementById(`card-${playerIndex}`).classList.remove('is-back');

        let dealerRank = hand[0].rank;
        let playerRank = hand[playerIndex].rank;
        
        // Joker in Double Up: Strongest card (Rank 15)
        // If hand[0] is Joker, dealerRank is 15.
        // If hand[playerIndex] is Joker, playerRank is 15.
        
        let dealerStr = hand[0].isJoker ? "JOKER" : (RANK_STR[dealerRank] || dealerRank);
        let playerStr = hand[playerIndex].isJoker ? "JOKER" : (RANK_STR[playerRank] || playerRank);

        gameState = 'ANIMATING'; 
        updateUI(); 

        setTimeout(() => {
            let pBadge = document.getElementById(`badge-${playerIndex}`);
            let isWin = false;
            let isLose = false;

            if (playerRank > dealerRank) {
                isWin = true;
                winAmount *= 2;
                consecutiveDoubles++;
                els.msg.innerText = `YOU WIN! (You:${playerStr} > Dealer:${dealerStr}) Total: ${winAmount}`;
                
                pBadge.innerText = "WIN!";
                pBadge.classList.add('win');
            } else if (playerRank < dealerRank) {
                isLose = true;
                els.msg.innerText = `YOU LOSE... (You:${playerStr} < Dealer:${dealerStr})`;
                pBadge.innerText = "LOSE";
                pBadge.classList.add('lose');
            } else {
                els.msg.innerText = `PUSH (You:${playerStr} = Dealer:${dealerStr}) Total: ${winAmount}`;
                pBadge.innerText = "PUSH";
            }
            
            revealAllCards(true); 

            let delay = isAutoMode ? 500 : 0;

            setTimeout(() => {
                if (isWin) {
                    gameState = 'WIN_DECISION'; 
                } else if (isLose) {
                    winAmount = 0;
                    consecutiveDoubles = 0;
                    loseGame();
                    return; 
                } else {
                    // Push
                    gameState = 'WIN_DECISION'; 
                }
                updateUI();
            }, delay);

        }, 600);
    }

    function revealAllCards(keepBadges = false) {
        for(let i=0; i<5; i++) {
             document.getElementById(`card-${i}`).classList.remove('is-back');
             if (!keepBadges) {
                 document.getElementById(`badge-${i}`).classList.remove('visible');
             }
        }
    }

    function collectWin() {
        credits += winAmount;
        winAmount = 0;
        consecutiveDoubles = 0;
        els.msg.innerText = "COLLECTED!";
        gameState = 'BETTING';
        for(let i=0; i<5; i++) document.getElementById(`card-${i}`).classList.add('is-back');
        
        for(let i=0; i<5; i++) {
            let b = document.getElementById(`badge-${i}`);
            b.classList.remove('visible');
            b.className = "status-badge";
        }

        updateUI();
    }

    function loseGame() {
        winAmount = 0;
        consecutiveDoubles = 0;
        if (credits === 0) {
            gameState = 'GAME_OVER';
            els.msg.innerText = "GAME OVER (Press RESTART)";
            if(isAutoMode) toggleAuto(); 
        } else {
            gameState = 'BETTING';
        }
        updateUI();
    }

    function toggleAuto() {
        isAutoMode = !isAutoMode;
        if (isAutoMode) {
            els.btnAuto.innerText = "STOP";
            els.btnAuto.classList.add('active');
            autoInterval = setInterval(autoTick, 1000); 
            autoTick(); 
        } else {
            els.btnAuto.innerText = "START";
            els.btnAuto.classList.remove('active');
            clearInterval(autoInterval);
            autoInterval = null;
        }
        updateUI();
    }

    function calculateSmartBet(risk) {
        let target = 1;
        if (risk === 'high') {
            target = 5;
        } else if (risk === 'mid') {
            if (credits >= 15) target = 5;
            else target = 1;
        } else {
            if (credits >= 50) target = 5;
            else if (credits >= 40) target = 4;
            else if (credits >= 30) target = 3;
            else if (credits >= 20) target = 2;
            else target = 1;
        }
        if (target > credits) target = credits;
        if (target < 1) target = 1; 
        return target;
    }

    function autoTick() {
        if (!isAutoMode) return;
        if (gameState === 'ANIMATING') return;

        const risk = els.riskSelect.value;

        if (gameState === 'BETTING') {
            let targetBet = calculateSmartBet(risk);
            if (credits < 1) return; 
            if (bet !== targetBet) {
                bet = targetBet;
                updateUI();
            }
            dealOrDraw(); 
        }
        else if (gameState === 'PLAYING') {
            const bestHolds = getBestHolds(hand);
            for (let i = 0; i < 5; i++) {
                if (bestHolds[i] !== held[i]) {
                    toggleHold(i);
                }
            }
            dealOrDraw(); 
        }
        else if (gameState === 'WIN_DECISION') {
            if (shouldDoubleUp(risk)) {
                startDoubleUp();
            } else {
                collectWin();
            }
        }
        else if (gameState === 'DOUBLE_UP') {
            const pick = Math.floor(Math.random() * 4) + 1;
            playDoubleUp(pick);
        }
        else if (gameState === 'GAME_OVER') {
            dealOrDraw(); 
        }
    }

    function getBestHolds(currentHand) {
        let holdMap = [false, false, false, false, false];
        
        // 1. Force Hold Joker
        let jokerIdx = -1;
        currentHand.forEach((c, i) => { if(c.isJoker) { holdMap[i] = true; jokerIdx = i; }});
        
        // Use Resolver to find hypothetical best hand
        // Simple logic for Joker: if we have Joker, check if we have other good components
        // If Joker exists, standard evaluation needs care.
        // For simplicity in Auto Mode with Joker:
        // - Always hold Joker
        // - Look for Pat Hands, 4K, 3K, 4-Flush, Pairs among NON-Joker cards
        
        // Temporary array without Joker for pattern matching
        let naturalCards = currentHand.filter(c => !c.isJoker);
        // Original indices map
        let naturalIndices = [];
        currentHand.forEach((c, i) => { if(!c.isJoker) naturalIndices.push(i); });

        let ranks = naturalCards.map(c => c.rank).sort((a,b)=>a-b);
        let suits = naturalCards.map(c => c.suit);
        
        let counts = {};
        ranks.forEach(x => { counts[x] = (counts[x] || 0) + 1; });
        let countValues = Object.values(counts);

        // If Joker is held, check what to keep with it
        if (jokerIdx !== -1) {
            // 4 of a kind (Natural) -> 5K
            if (countValues.includes(4)) return [true, true, true, true, true];
            // 3 of a kind -> 4K
            if (countValues.includes(3)) {
                let r = parseInt(Object.keys(counts).find(k => counts[k] === 3));
                currentHand.forEach((c, i) => { if(c.rank === r) holdMap[i] = true; });
                return holdMap;
            }
            // 3 to a Royal (very simplified)
            // 4 to a Flush
            for (let s of SUITS) {
                let suited = naturalIndices.filter(idx => currentHand[idx].suit === s);
                if (suited.length >= 3) { // Joker makes 4
                    suited.forEach(idx => holdMap[idx] = true);
                    return holdMap;
                }
            }
            // Pair -> 3K
            if (countValues.includes(2)) {
                let r = parseInt(Object.keys(counts).find(k => counts[k] === 2));
                currentHand.forEach((c, i) => { if(c.rank === r) holdMap[i] = true; });
                return holdMap;
            }
            // High Cards
             currentHand.forEach((c, i) => { if(c.rank >= 11) holdMap[i] = true; });
             return holdMap;
        }

        // --- Standard Logic (No Joker) ---
        // Same as before
        
        let isFlush = suits.every(s => s === suits[0]);
        let isStraight = true;
        for(let i=0; i<4; i++) if(ranks[i+1] !== ranks[i] + 1) isStraight = false;
        if (!isStraight && ranks.join(',') === '2,3,4,5,14') isStraight = true; 

        let isPatHand = false;
        if (isFlush && isStraight) isPatHand = true; 
        if (countValues.includes(3) && countValues.includes(2)) isPatHand = true; 
        if (isFlush) isPatHand = true;
        if (isStraight) isPatHand = true;

        if (isPatHand) return [true, true, true, true, true];

        if (countValues.includes(4)) {
            let rank4 = parseInt(Object.keys(counts).find(key => counts[key] === 4));
            for(let i=0; i<5; i++) {
                if (currentHand[i].rank === rank4) holdMap[i] = true;
            }
            return holdMap;
        }

        if (countValues.includes(3)) {
            let rank3 = parseInt(Object.keys(counts).find(key => counts[key] === 3));
            for(let i=0; i<5; i++) {
                if (currentHand[i].rank === rank3) holdMap[i] = true;
            }
            return holdMap;
        }

        if (countValues.filter(x => x === 2).length === 2) {
            let pairRanks = Object.keys(counts).filter(key => counts[key] === 2).map(Number);
            for(let i=0; i<5; i++) {
                if (pairRanks.includes(currentHand[i].rank)) holdMap[i] = true;
            }
            return holdMap;
        }

        if (countValues.includes(2)) {
            let pairRank = parseInt(Object.keys(counts).find(key => counts[key] === 2));
            for(let i=0; i<5; i++) {
                if (currentHand[i].rank === pairRank) holdMap[i] = true;
            }
            return holdMap;
        }

        for (let s of SUITS) {
            let suitedIndices = [];
            currentHand.forEach((c, idx) => { if(c.suit === s) suitedIndices.push(idx); });
            if (suitedIndices.length === 4) {
                suitedIndices.forEach(idx => holdMap[idx] = true);
                return holdMap;
            }
        }

        let heldHigh = false;
        for(let i=0; i<5; i++) {
            if (currentHand[i].rank >= 11) {
                holdMap[i] = true;
                heldHigh = true;
            }
        }
        
        return holdMap;
    }

    function shouldDoubleUp(risk) {
        if (risk === 'low') {
            return false; 
        } else if (risk === 'mid') {
            if (consecutiveDoubles === 0 && winAmount < 100) return true;
            return false;
        } else if (risk === 'high') {
            if (consecutiveDoubles < 5 && winAmount < 1000) return true;
            return false;
        }
        return false;
    }

    function updateUI() {
        els.credits.innerText = credits;
        els.bet.innerText = bet;
        els.win.innerText = winAmount;

        let isAnimating = (gameState === 'ANIMATING');
        let controlsDisabled = isAnimating || isAutoMode;
        
        els.btnBetOne.disabled = controlsDisabled || (gameState !== 'BETTING');
        els.btnBetMax.disabled = controlsDisabled || (gameState !== 'BETTING');
        
        if (isAnimating) {
             els.btnDeal.disabled = true;
             els.doubleControls.style.display = "none";
             return; 
        }
        
        if (gameState === 'BETTING') {
            els.btnDeal.innerText = "DEAL";
            els.btnDeal.style.display = "inline-block";
            els.doubleControls.style.display = "none";
            els.btnDeal.disabled = controlsDisabled || (credits === 0);

        } else if (gameState === 'PLAYING') {
            els.btnDeal.innerText = "DRAW";
            els.btnDeal.style.display = "inline-block";
            els.doubleControls.style.display = "none";
            els.btnDeal.disabled = controlsDisabled;

        } else if (gameState === 'WIN_DECISION') {
            els.btnDeal.style.display = "none";
            els.doubleControls.style.display = "flex";
            if(isAutoMode) {
                 Array.from(els.doubleControls.children).forEach(btn => btn.disabled = true);
            } else {
                 Array.from(els.doubleControls.children).forEach(btn => btn.disabled = false);
            }

        } else if (gameState === 'DOUBLE_UP') {
            els.btnDeal.style.display = "none";
            els.doubleControls.style.display = "none"; 

        } else if (gameState === 'GAME_OVER') {
            els.btnDeal.innerText = "RESTART";
            els.btnDeal.style.display = "inline-block";
            els.doubleControls.style.display = "none";
            els.btnDeal.disabled = controlsDisabled;
        }
    }

    init();

</script>
</body>
</html>